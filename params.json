{"name":"Rackus","tagline":"Backus-Naur grammars for Ruby","body":"# Rackus\r\nRackus allows Backus-Naur defined grammars to be tested and read\r\nin Ruby. Currently, a DSL is used to define these grammars. Eventually,\r\nit will become a self-hosted grammar parser which uses true BNF as input.\r\n\r\n## Getting Started\r\nRackus is a lot like Regular Expressions, except more appropriate for\r\nparsers. Require the library to get started.\r\n\r\n```ruby\r\nrequire './rackus.rb'\r\n```\r\n\r\nForm an expression pattern using `And`, `Or`, and `Token` \r\n(together with `Rackus#register!`). Here's a very basic example.\r\n\r\n```ruby\r\nalphabeta = (Const 'A') | (Const 'B')\r\nalphabeta.test 'A' # => true\r\nalphabeta.test 'B' # => true\r\nalphabeta.test 'C' # => false\r\n```\r\n\r\nMore complicated expressions arise by use of recursion. Here is an example\r\nof this approach.\r\n\r\n```ruby\r\nbs = (Const 'B') | ((Const 'B') + (Token :b))\r\nbs.register! :b, bs\r\n\r\nbs.test 'b' # => true\r\nbs.test 'bb' # => true\r\nbs.test 'bbbb' # => true\r\nbs.test 'bab' # => false\r\n```\r\n\r\n## Parsing\r\nRackus is not limited to RegEx-like testing. Rather, Rackus can be used\r\nto extract structure from strings. This is done by use of `Rackus#read`.\r\nLet's look at an example, in which we use Rackus to analyze a grammar.\r\n\r\n```ruby\r\nsum = (Token :bit) + (Token :op) + ((Token :sum) | (Token :bit))\r\nsum.register! :bit, ((Const '0') | (Const '1'))\r\nsum.register! :op, ((Const '+') | (Const '*') | (Const '-'))\r\nsum.register! :sum, sum\r\n\r\nsum.read('0+1').map(&:name) == [:bit, :op, :bit] # => true\r\nsum.read('0+1+0').map(&:name) == [:bit, :op, :bit] # => false\r\n```\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}